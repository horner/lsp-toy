#!/usr/bin/env node
// Bundled Language Server - Generated by LSP-Toy
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/bundled-servers/json-server.ts
var json_server_exports = {};
__export(json_server_exports, {
  BundledJSONServer: () => BundledJSONServer
});
module.exports = __toCommonJS(json_server_exports);
var import_node = require("vscode-languageserver/node");
var import_vscode_languageserver_textdocument = require("vscode-languageserver-textdocument");
var BundledJSONServer = class {
  connection = (0, import_node.createConnection)(import_node.ProposedFeatures.all);
  documents = new import_node.TextDocuments(import_vscode_languageserver_textdocument.TextDocument);
  hasConfigurationCapability = false;
  constructor() {
    this.setupHandlers();
  }
  setupHandlers() {
    this.connection.onInitialize((params) => {
      const capabilities = params.capabilities;
      this.hasConfigurationCapability = !!(capabilities.workspace && !!capabilities.workspace.configuration);
      const result = {
        capabilities: {
          textDocumentSync: import_node.TextDocumentSyncKind.Incremental,
          completionProvider: {
            resolveProvider: false,
            triggerCharacters: ['"', ":", ",", "{", "["]
          },
          hoverProvider: true,
          documentSymbolProvider: true
        }
      };
      return result;
    });
    this.connection.onInitialized(() => {
      if (this.hasConfigurationCapability) {
        this.connection.client.register(import_node.DidChangeConfigurationNotification.type, void 0);
      }
    });
    this.connection.onCompletion(this.handleCompletion.bind(this));
    this.connection.onHover(this.handleHover.bind(this));
    this.documents.onDidChangeContent((change) => {
      this.validateDocument(change.document);
    });
    this.documents.listen(this.connection);
    this.connection.listen();
  }
  validateDocument(document) {
    const text = document.getText();
    const diagnostics = [];
    try {
      JSON.parse(text);
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      const match = errorMessage.match(/position (\d+)/);
      const position = match ? parseInt(match[1]) : 0;
      const documentPosition = document.positionAt(position);
      diagnostics.push({
        severity: import_node.DiagnosticSeverity.Error,
        range: {
          start: documentPosition,
          end: { line: documentPosition.line, character: documentPosition.character + 1 }
        },
        message: `JSON syntax error: ${errorMessage}`,
        source: "json"
      });
    }
    this.connection.sendDiagnostics({
      uri: document.uri,
      diagnostics
    });
  }
  handleCompletion(textDocumentPosition) {
    const document = this.documents.get(textDocumentPosition.textDocument.uri);
    if (!document) {
      return [];
    }
    const text = document.getText();
    const offset = document.offsetAt(textDocumentPosition.position);
    const beforeCursor = text.substring(0, offset);
    const completions = [];
    if (beforeCursor.endsWith('"') || beforeCursor.match(/"[^"]*$/)) {
      completions.push(
        {
          label: "name",
          kind: import_node.CompletionItemKind.Property,
          insertText: 'name": "'
        },
        {
          label: "version",
          kind: import_node.CompletionItemKind.Property,
          insertText: 'version": "'
        },
        {
          label: "description",
          kind: import_node.CompletionItemKind.Property,
          insertText: 'description": "'
        },
        {
          label: "type",
          kind: import_node.CompletionItemKind.Property,
          insertText: 'type": "'
        }
      );
    }
    if (beforeCursor.match(/:\s*$/)) {
      completions.push(
        {
          label: "true",
          kind: import_node.CompletionItemKind.Value,
          insertText: "true"
        },
        {
          label: "false",
          kind: import_node.CompletionItemKind.Value,
          insertText: "false"
        },
        {
          label: "null",
          kind: import_node.CompletionItemKind.Value,
          insertText: "null"
        }
      );
    }
    return completions;
  }
  handleHover(params) {
    const document = this.documents.get(params.textDocument.uri);
    if (!document) {
      return null;
    }
    const text = document.getText();
    const offset = document.offsetAt(params.position);
    const wordRange = this.getWordRangeAtPosition(document, params.position);
    if (!wordRange) {
      return null;
    }
    const word = text.substring(
      document.offsetAt(wordRange.start),
      document.offsetAt(wordRange.end)
    );
    const hoverInfo = {
      "true": "Boolean value: true",
      "false": "Boolean value: false",
      "null": "Represents null value",
      "name": "Package name property",
      "version": "Version identifier",
      "description": "Package description"
    };
    const info = hoverInfo[word];
    if (info) {
      return {
        contents: {
          kind: import_node.MarkupKind.Markdown,
          value: `**${word}**

${info}`
        },
        range: wordRange
      };
    }
    return null;
  }
  getWordRangeAtPosition(document, position) {
    const text = document.getText();
    const offset = document.offsetAt(position);
    let start = offset;
    let end = offset;
    while (start > 0 && /\w/.test(text[start - 1])) {
      start--;
    }
    while (end < text.length && /\w/.test(text[end])) {
      end++;
    }
    if (start === end) {
      return null;
    }
    return {
      start: document.positionAt(start),
      end: document.positionAt(end)
    };
  }
};
if (require.main === module) {
  new BundledJSONServer();
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  BundledJSONServer
});
//# sourceMappingURL=json-server.js.map
